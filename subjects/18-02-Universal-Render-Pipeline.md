# 18.2 Universal Render Pipeline (URP)

[← Back to Chapter 18](../chapters/18-Scriptable-Render-Pipeline.md) | [Main Index](../README.md)

URP is Unity's cross-platform SRP optimized for mobile, consoles, and VR: single-pass forward rendering, optimized shaders, Shader Graph integration, and 2D renderer.

---

## Overview

URP Philosophy: Performance-first rendering (optimized for all platforms, especially mobile/Switch), simplicity (easier than HDRP, fewer features but faster), cross-platform (same pipeline on PC/console/mobile/VR). Replaces LWRP (Lightweight Render Pipeline, URP is evolution/rebranding). Key benefits: faster than Built-In pipeline (20-50% better performance on mobile/Switch, optimized shaders + single-pass forward), Shader Graph support (visual shader authoring, no code required), scalable quality (quality presets: Low/Medium/High, adjust shadows/post-processing/textures).

Rendering Path: Single-pass forward renderer (all lighting calculated in fragment shader, one pass per object). Supports: multiple lights (main directional + additional point/spot lights, configurable limit), shadows (main light + additional light shadows, cascade shadows for directional), post-processing (integrated Post Processing Stack v2, bloom, color grading, depth of field). Deferred rendering (experimental in URP 12+, optional for desktop/console, forward still default). 2D renderer (optimized for sprite-based games, lighting for 2D, normal maps, sprite sorting).

Shader Integration: URP shaders (URP/Lit = PBR, URP/Unlit = unlit, URP/SimpleLit = mobile-optimized Blinn-Phong). Shader Graph (create custom shaders visually, URP-specific nodes, no code). ShaderLab (code custom shaders, use URP shader library: `#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"`). Built-In incompatible (Standard shader doesn't work, must upgrade materials to URP shaders).

## Key Concepts

- **UniversalRenderPipelineAsset**: Settings asset (Project Settings > Graphics > SRP Settings = assign URP asset). Configures: rendering (Forward/Deferred), quality (Main Light Shadows, Additional Lights count, Shadow Distance), post-processing (HDR, MSAA, post-processing enabled). Multiple assets: Low/Medium/High quality (different shadow/light settings, switch per platform/quality level). Create: Assets > Create > Rendering > URP Asset (with Universal Renderer).
- **Forward Renderer**: Default URP renderer (single forward pass, all lighting in fragment shader). Features: main directional light (always rendered, shadows supported), additional lights (point/spot, configurable count: 0-8 per object, shadows optional), per-pixel lighting (quality), per-vertex lighting (performance, mobile option). Settings: UniversalRendererData asset (Rendering > Renderer Features, Opaque/Transparent pass settings), assigned in URP asset (Renderer List = add Forward Renderer).
- **Deferred Renderer** (experimental): Optional for desktop/console (URP 12+), writes G-buffer (albedo, normal, specular, emission to render targets), lighting pass (reads G-buffer, calculates lighting for all lights). Benefits: many lights (100+ lights efficient, no per-object light limit), consistent cost (lighting cost proportional to screen pixels, not object count). Drawbacks: mobile unsupported (requires MRT, not viable on tile-based GPUs), higher memory (G-buffer textures: ~20MB at 1080p), no MSAA (deferred incompatible with MSAA, use FXAA/TAA instead). Enable: URP asset > Rendering Path = Deferred.
- **2D Renderer**: Optimized for sprite games (2D Lights, normal maps for 2D, sprite sorting). Features: 2D Lights (point/spot/global lights, sprites lit via normal maps), blend modes (additive, multiply for 2D effects), sorting (sprite sorting by order, layer-based). Setup: Create URP asset with 2D Renderer (Assets > Create > Rendering > URP Asset (2D Renderer)), assign to Graphics settings. Shaders: Sprite-Lit (receives 2D lighting), Sprite-Unlit (no lighting). Editor: 2D project template includes URP 2D by default.
- **Renderer Features**: Scriptable render passes (customize URP rendering, inject custom effects). Built-in features: Render Objects (render specific objects with override material, e.g., outline pass), Screen Space Ambient Occlusion (SSAO, adds occlusion in screen space). Custom features: ScriptableRendererFeature subclass (adds custom pass to URP pipeline). Example: RenderObjectsFeature renders all objects on "Outline" layer with outline shader (second pass after main rendering). Add: UniversalRendererData > Renderer Features > Add Renderer Feature.
- **URP Shader Library**: HLSL includes for URP shaders (lighting, shadows, fog). Core: `Core.hlsl` (matrices, transforms, camera data), `Lighting.hlsl` (lighting functions, PBR, shadows), `Shadows.hlsl` (shadow sampling, cascade shadows). Usage: `#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"` Access functions: `GetMainLight()`, `CalculateBlinnPhong()`, `SampleShadowmap()`. Shader Graph: nodes auto-generate URP shader code (custom shaders without manual HLSL).

## Best Practices

**URP Setup for Projects:**
- New project: Unity Hub > URP Template (pre-configured URP, sample scenes, shaders). Or: create empty project, install URP package (Window > Package Manager > Universal RP, install), create URP asset (Assets > Create > Rendering > URP Asset), assign (Project Settings > Graphics > Scriptable Render Pipeline Settings = URP asset).
- Existing project upgrade: Edit > Render Pipeline > Universal > Upgrade Project Materials to URP (converts Built-In materials to URP shaders), manually fix custom shaders (replace Built-In includes with URP includes, test rendering). Validate: Frame Debugger shows URP passes, no magenta materials (incompatible shaders).
- Quality presets: Create multiple URP assets (URP_Low, URP_Medium, URP_High), configure per asset (Low = 0 additional lights, no shadows, Medium = 1 additional light, soft shadows, High = 4 additional lights, high-res shadows), assign per platform/quality (Quality Settings > Levels > assign URP asset per level).

**Lighting Configuration:**
- Main Light: Always enabled (URP asset > Lighting > Main Light = Directional), supports shadows (cascade shadows, 1-4 cascades), high quality (soft shadows option for PCF filtering). Typically: one directional light (sun, main scene illumination), shadows on (critical for depth perception).
- Additional Lights: Configurable count (URP asset > Lighting > Additional Lights = Per Pixel/Per Vertex/Disabled, Max Per Object Pixel Light Count = 0-8). Per-pixel: higher quality (point/spot lights with normal maps, specular), expensive (per-light calculations in fragment shader). Per-vertex: cheaper (lighting at vertices, interpolated, mobile-friendly), lower quality (no specular, blocky lighting on low-poly meshes). Mobile: 0-1 additional lights (main light only, or single additional), PC: 4-8 additional lights.
- Shadows: Main Light Shadows (enable, set Shadow Resolution: Low/Medium/High/Very High = 512/1024/2048/4096), Additional Light Shadows (optional, expensive on mobile, enable for important point/spot lights). Shadow Distance (URP asset > Shadows > Max Distance = 50-150m, beyond distance no shadows rendered). Cascades: 1-4 (URP asset > Shadows > Cascade Count, more cascades = better quality near camera, 4 cascades typical for PC, 2 for mobile/Switch).
- Baked Lighting: URP supports (lightmaps, light probes, reflection probes), setup via Lighting window (Window > Rendering > Lighting, same as Built-In). Mixed lighting (Baked Indirect, Shadowmask supported, Subtractive deprecated in URP). Realtime GI not supported (Enlighten removed, use light probes + reflection probes instead).

**Shader Graph Workflow:**
- Create Shader Graph: Assets > Create > Shader > URP > Lit/Unlit Shader Graph (opens Shader Graph editor). Nodes: add inputs (Texture2D, Color, Float), processing (Multiply, Add, Lerp), output (connects to Master Stack: Base Color, Normal, Metallic, Smoothness). Material: create material (Assets > Create > Material), assign Shader Graph shader (Material > Shader = Shader Graphs/MyShader).
- URP-specific nodes: Main Light (gets main directional light color/direction), Additional Lights (loops additional lights, calculates contribution), Baked GI (samples lightmaps), Ambient (samples ambient lighting). Lighting models: PBR (Lit Shader Graph, physically-based), Unlit (no lighting, Unlit Shader Graph), custom (use Custom Function node, write HLSL code).
- Performance: Keep node count low (complex graphs = expensive shaders, mobile performance degrades), use texture samplers efficiently (minimize texture reads, combine channels), preview (Shader Graph shows material preview, validate appearance). Shader variants: avoid multi_compile in Shader Graph (generates many variants, long compile times, use static branches or properties instead).

**Renderer Features Usage:**
- Screen Space Ambient Occlusion (SSAO): Add feature (UniversalRendererData > Renderer Features > Add > Screen Space Ambient Occlusion), configure (intensity, radius, sample count). Performance cost (additional post-processing pass, ~1-2ms on PC, 2-5ms on mobile), quality improvement (adds depth/contact shadows, enhances realism). Mobile: disable or low quality (high cost, minimal visual gain on small screens).
- Render Objects Feature: Custom rendering pass (renders specific objects with override material/settings). Use cases: outline effect (render all objects on "Outline" layer with outline shader, second pass), X-ray vision (render occluded objects with transparent material, see through walls). Setup: Add feature (UniversalRendererData > Renderer Features > Add > Render Objects), configure (Layer Mask = which objects, Override Material = custom shader, Event = when in pipeline: AfterRenderingOpaques/AfterRenderingTransparents).
- Custom Renderer Features: Create ScriptableRendererFeature subclass (defines custom pass, configures settings), add ScriptableRenderPass (implements pass rendering logic, CommandBuffer commands). Example: custom post-processing effect (reads camera color, applies effect, writes back). Add to renderer (UniversalRendererData > Renderer Features > Add > Custom Feature, appears in list).

**Platform-Specific:**
- **PC**: URP High settings (4-8 additional lights, 4 cascade shadows, high-resolution shadows 2048/4096, MSAA 4x, full post-processing), forward or deferred (deferred for many lights >8, forward otherwise). Shader complexity: moderate (PBR with normal/metallic/occlusion maps, Shader Graph custom effects). Performance: 60-120 FPS target (URP faster than Built-In, supports high-end features).
- **Consoles**: URP Medium/High settings (2-4 additional lights, 2-4 cascade shadows, medium shadows 1024/2048, MSAA 2-4x, moderate post-processing), forward renderer (deferred optional for PS5/Xbox Series X if many lights). Shader complexity: standard PBR (similar to PC, optimized shaders). Performance: locked 30/60 FPS (URP stable performance, predictable frame times).
- **Switch**: URP Low settings (0-1 additional lights, main light only shadows, low shadows 512/1024, 2 cascades, no MSAA, minimal post-processing: bloom + color grading only), forward renderer only. Shader complexity: SimpleLit (Blinn-Phong instead of PBR, cheaper), limit texture samplers (2-3 textures max: albedo + normal + combined metallic/smoothness/AO). Performance: 30 FPS target (aggressive optimization, URP essential for viability), handheld mode (reduce resolution 720p → 540p dynamic, maintain frame rate).
- **Mobile**: URP Mobile preset (0 additional lights, main light only, no shadows or low-resolution 512, 1 cascade, no MSAA, no post-processing or color grading only), forward renderer only. Shader complexity: Unlit or SimpleLit (no PBR, avoid normal maps on low-end, single texture preferred), Shader Graph sparingly (complex graphs = slow shaders). Performance: 30-60 FPS target (30 on low-end, 60 on high-end), tile-based rendering (URP optimized for mobile GPUs, minimizes bandwidth).

## Common Pitfalls

**Built-In Shaders Breaking**: Developer enables URP (assigns URP asset), all materials turn magenta (Standard shader incompatible with URP, surface shaders don't work). Symptom: All objects pink/magenta (fallback shader), Game view broken, console warnings ("Shader not supported"). Solution: Upgrade materials (Edit > Render Pipeline > Universal > Upgrade Project Materials to URP, automatically converts Standard to URP/Lit), update custom shaders (replace Built-In includes with URP: `#include "Packages/.../universal/ShaderLibrary/Core.hlsl"`, rewrite surface shaders as vertex/fragment shaders using URP lighting functions).

**Post-Processing Not Working**: Developer enables URP, adds Post-Processing Volume (expecting effects to work), nothing happens (URP uses integrated post-processing, not Post-Processing Stack v2 package). Symptom: Bloom/color grading not visible, Volume component has no effect, no errors. Solution: Use URP post-processing (add Volume component to GameObject, create Volume Profile, add overrides: Bloom, Color Grading, etc., ensure camera has Post-Processing enabled in Camera component), remove Post-Processing Stack v2 package (conflicts with URP, uninstall from Package Manager).

**Too Many Lights**: Developer places 20 point lights in scene (thinking all render), performance tanks (URP limits additional lights per object, exceeding limit = expensive per-pixel calculations, or lights ignored). Symptom: Low frame rate (Profiler shows lighting expensive), lights flickering (URP selects closest N lights, distant lights excluded = visual popping as camera moves). Solution: Reduce light count (use baked lighting for static lights, limit realtime lights to 2-4 critical sources), increase URP light limit (URP asset > Lighting > Max Per Object Pixel Lights = 8, but expensive on mobile), or use lightmaps (bake static lights, only dynamic lights realtime).

**MSAA Not Working in Deferred**: Developer enables deferred rendering (URP asset > Rendering Path = Deferred), enables MSAA (URP asset > Quality > MSAA = 4x), no antialiasing visible (deferred incompatible with MSAA, G-buffer rendering doesn't support MSAA). Symptom: Jagged edges remain, MSAA setting ignored, no console errors (silently disabled). Solution: Use post-processing AA (enable FXAA or TAA in Volume Profile, post-process antialiasing compatible with deferred), or switch to forward rendering (Forward path supports MSAA, change URP asset > Rendering Path = Forward if MSAA critical).

## Tools & Workflow

**URP Asset Creation**: Assets > Create > Rendering > Universal Render Pipeline > Pipeline Asset (Forward Renderer) or Pipeline Asset (2D Renderer). Generates: UniversalRenderPipelineAsset (settings), UniversalRendererData (renderer configuration). Configure: select URP asset, Inspector shows settings (Quality, Lighting, Shadows, Post-processing). Assign: Project Settings > Graphics > Scriptable Render Pipeline Settings = drag URP asset.

**Material Upgrader**: Edit > Render Pipeline > Universal Render Pipeline > Upgrade Project Materials to UniversalRP. Scans project (finds all materials using Built-In shaders), converts (Standard → URP/Lit, Standard (Specular) → URP/Lit with specular workflow, Unlit → URP/Unlit). Backup first (File > Save Project, or version control commit, upgrader modifies assets). Post-upgrade: validate (check materials render correctly, fix custom shaders manually).

**Shader Graph**: Window > Shader Graph (opens Shader Graph window for selected shader). Create: right-click Project > Create > Shader > URP > Lit/Unlit Shader Graph. Edit: double-click shader asset (opens graph editor), add nodes (right-click > Create Node, search for operations), connect (drag pins between nodes), output to Master Stack (Base Color, Normal, Metallic, Smoothness, Emission, Alpha). Save: Ctrl+S (compiles shader, hot-reloads in Editor). Material: create material, assign Shader Graph shader (Material > Shader = Shader Graphs/YourShader).

**Volume Profiles**: Assets > Create > Volume Profile (creates profile asset). Add overrides: select profile, Inspector > Add Override (Bloom, Color Adjustments, Depth of Field, etc.). Configure: expand override (adjust parameters: Bloom Intensity, Saturation, etc.). Apply: create GameObject with Volume component (GameObject > Volume > Global Volume or Box Volume), assign profile (Volume > Profile = your Volume Profile asset). Global volumes affect entire scene, local volumes (Box/Sphere Volume) affect camera when inside bounds.

**URP Debugger**: Window > Analysis > Rendering Debugger (URP-specific debugging). Displays: frame rendering stats (draw calls, triangles, batches), lighting info (light counts, shadow cascades), material properties (albedo, metallic, smoothness, validation modes: overdraw, mipmap levels). Usage: toggle overlays (Material > Albedo shows albedo only, Lighting > No Lighting disables lighting for debugging), overdraw mode (shows pixel overdraw, identifies expensive transparency).

**Frame Debugger**: Window > Analysis > Frame Debugger (step through URP rendering). Shows: URP passes (Shadow Caster Pass, Forward Opaques, Skybox, Forward Transparents, Post-Processing), draw calls per pass (expand to see individual objects rendered), state changes (render targets, shaders, material properties). Usage: identify bottlenecks (passes with many draw calls, expensive shaders), validate rendering order (opaques before transparents, shadows before lighting).

## Related Topics

- [18.1 SRP Architecture](18-01-SRP-Architecture.md) - SRP fundamentals
- [18.3 High-Definition Render Pipeline](18-03-High-Definition-Render-Pipeline.md) - HDRP comparison
- [12.1 Introduction to Shaders](12-01-Introduction-To-Shaders.md) - Shader basics
- [12.4 Shader Graph](12-04-Shader-Graph.md) - Visual shader authoring

---

[← Previous: 18.1 SRP Architecture](18-01-SRP-Architecture.md) | [Next: 18.3 High-Definition Render Pipeline →](18-03-High-Definition-Render-Pipeline.md)
