# 18.4 Built-In Render Pipeline (Legacy)

[← Back to Chapter 18](../chapters/18-Scriptable-Render-Pipeline.md) | [Main Index](../README.md)

Built-In Render Pipeline is Unity's legacy fixed-function renderer: forward/deferred paths, Standard shader, established workflow, but deprecated in favor of URP/HDRP.

---

## Overview

Built-In Pipeline: Unity's original rendering (pre-SRP era, before Unity 2019), hardcoded C++ implementation (not scriptable, fixed forward/deferred paths, no customization). Still available (default for old projects, maintained for compatibility), but deprecated (Unity recommends URP/HDRP for new projects, Built-In receives minimal updates). Legacy support (existing projects continue using Built-In, migration to SRP recommended but optional).

Rendering Paths: Forward (default, lighting calculated per-object, supports all features), Deferred (G-buffer rendering, many lights efficient, some limitations), Vertex Lit (legacy mobile, per-vertex lighting, deprecated = use URP instead). Forward supports: all shader types (surface shaders, vertex/fragment), transparency (alpha blending), MSAA (multisampling anti-aliasing). Deferred: many lights (100+ lights performant), no transparency (opaque only, transparent objects fall back to forward), no MSAA (incompatible with G-buffer).

Standard Shader: Built-In's PBR material (physically-based rendering, metallic/specular workflows, normal/occlusion/emission maps). Features: two workflows (Metallic = metals + dielectrics, Specular = explicit specular color control), detail maps (secondary textures for close-up detail), height maps (parallax mapping for depth), emission (self-illuminated materials). Lighting: realtime (dynamic lights, calculated per-frame), baked (lightmaps, light probes, reflection probes), mixed (realtime shadows on baked lighting). Post-processing: requires Post-Processing Stack v2 package (separate from Built-In, installed via Package Manager).

## Key Concepts

- **Forward Rendering Path**: Default Built-In path (calculates lighting in forward pass, per-object fragment shader). Process: base pass (first directional light + ambient + lightmaps, one pass per object), additional passes (one pass per additional light, additive blending, expensive for many lights). Lighting limit: 4 pixel lights per object (configurable in Quality Settings, additional lights rendered as vertex-lit or SH). Supports: transparency (alpha blending in forward pass), MSAA (2x/4x/8x, Quality Settings), all shader features (surface shaders fully functional). Best for: scenes with few lights (1-4 lights typical, more = expensive), mobile (forward cheaper on tile-based GPUs), transparency-heavy scenes.
- **Deferred Rendering Path**: Alternative path (writes G-buffer, lighting calculated in screen-space pass). Process: G-buffer pass (writes albedo, specular, normal, emission to render targets), lighting pass (reads G-buffer, calculates lighting for all lights, screen-space = one pass for all lights). Lighting: unlimited lights (100+ lights with constant cost, lighting proportional to screen pixels not object count), shadows (all lights can cast shadows, up to quality limits). Limitations: no transparency in deferred (transparent objects rendered in forward pass after deferred, two rendering paths mixed), no MSAA (G-buffer incompatible, use post-process AA instead), higher memory (G-buffer textures: albedo, specular, normal, depth = ~20MB at 1080p). Best for: many lights (10+ lights, open interiors with many lamps), desktop/console (sufficient memory for G-buffer, mobile incompatible).
- **Standard Shader**: Built-In PBR material (replaces legacy Diffuse/Specular shaders). Workflows: Metallic (Metallic slider 0-1, 0=dielectric, 1=metal, Smoothness for roughness), Specular (Specular color RGB, Smoothness, more control for non-metals). Texture slots: Albedo (base color + alpha), Metallic/Specular (workflow-dependent map), Normal (tangent-space normal map), Height (parallax occlusion mapping), Occlusion (ambient occlusion mask), Emission (self-illumination), Detail (secondary albedo/normal for tiling detail). Rendering Mode: Opaque (solid objects, depth tested), Cutout (alpha testing, foliage), Transparent (alpha blending, sorted), Fade (dithered fade, LOD crossfading).
- **Surface Shaders**: Built-In's simplified shader syntax (Unity compiles to vertex/fragment, handles lighting automatically). Code: `#pragma surface surf Standard` (defines surface function, lighting model). Surface function: `void surf (Input IN, inout SurfaceOutputStandard o) { o.Albedo = tex2D(_MainTex, IN.uv_MainTex).rgb; o.Metallic = _Metallic; o.Smoothness = _Smoothness; }` Unity generates lighting code (forward/deferred passes auto-generated, developer only writes surface properties). Benefits: easier than manual lighting (no need to code Blinn-Phong/PBR, Unity handles), shorter code (20 lines vs 200+ for manual lighting). Drawbacks: less control (can't customize render pipeline, fixed lighting), performance overhead (generated code not always optimal, manual shaders can be faster), SRP incompatible (surface shaders don't work in URP/HDRP, must rewrite as vertex/fragment).
- **Legacy Lighting**: Built-In lighting window (Window > Rendering > Lighting Settings). Baking: Progressive Lightmapper (GPU-based baking, default), or Enlighten (legacy realtime GI, deprecated). Mixed Lighting: Baked Indirect (bakes indirect light, realtime direct + shadows), Shadowmask (bakes shadows beyond distance, blends realtime/baked), Subtractive (legacy, not recommended). Light Probes (for dynamic objects, sample baked lighting), Reflection Probes (for reflections, baked or realtime cubemaps). Ambient: Skybox (IBL from skybox), Gradient (tricolor ambient: sky/equator/ground), Color (flat ambient color).
- **Quality Settings**: Project Settings > Quality (defines quality levels: Very Low/Low/Medium/High/Ultra). Per-level settings: Pixel Light Count (forward path max per-object lights, 0-8), Texture Quality (full/half/quarter resolution), Anisotropic Textures (per-texture/forced on/disabled), Anti Aliasing (disabled/2x/4x/8x MSAA), Soft Particles (depth-based fade), Shadows (Hard/Soft, resolution, distance, cascades), Shadow Projection (Stable Fit/Close Fit), Realtime Reflection Probes (enabled/disabled). Platform overrides (set different quality per platform: PC=Ultra, Console=High, Mobile=Low).

## Best Practices

**When to Use Built-In:**
- Legacy projects: Existing projects using Built-In (migration to SRP = significant work, if project shipping soon continue with Built-In, defer migration to post-launch). Asset compatibility (old assets designed for Built-In, Standard shader materials, surface shader code).
- Learning/prototyping: Simplicity (Built-In well-documented, many tutorials, beginner-friendly), rapid prototyping (no pipeline setup, drag-and-drop Standard shader works immediately). Once prototype validated, consider migrating to URP (better performance, future-proof).
- Avoid for new projects: URP recommended (better performance, cross-platform, maintained), HDRP for high-end (AAA graphics, PC/console). Built-In deprecated (minimal updates, no new features, eventual removal likely in Unity 6+). Exception: team expertise (if team highly experienced with Built-In, project deadline tight, stick with known pipeline, but document migration path).

**Forward vs Deferred:**
- Choose Forward if: Few lights (1-4 lights per scene, typical for outdoor/simple indoor), transparency-heavy (many alpha-blended effects, particles, UI), mobile/Switch (forward cheaper on tile-based GPUs, deferred unsupported on many mobile devices), MSAA required (forward supports MSAA, deferred incompatible).
- Choose Deferred if: Many lights (10+ lights, complex indoor lighting with lamps/torches), desktop/console only (sufficient memory for G-buffer, mobile excluded), no transparency issues (opaque-heavy scenes, minimal alpha blending). Settings: Player Settings > Other Settings > Rendering Path = Deferred, Quality Settings > Pixel Light Count irrelevant (deferred ignores limit).
- Mixed approach: Per-camera override (Camera component > Rendering Path = Use Player Settings/Forward/Deferred, reflection cameras use forward, main camera uses deferred). Per-platform (PC/console = deferred, mobile = forward via platform-specific quality settings).

**Standard Shader Usage:**
- Metallic workflow: For metals and non-metals (Metallic=1 for iron/gold/steel, Metallic=0 for wood/plastic/stone). Metallic map (grayscale texture, white=metal, black=dielectric, allows mixed materials like rusty metal). Smoothness (0=rough, 1=mirror, typically 0.2-0.8, extreme values rare). Combine maps (pack Metallic + Smoothness into single texture: Metallic in RGB, Smoothness in Alpha, saves texture slot).
- Specular workflow: For precise specular control (Specular color = RGB reflectance at normal incidence, black=no reflection, white=full reflection). Use cases: skin (low specular with warm tint), water (high specular blue-tinted), cloth (anisotropic specular approximation). Smoothness separate (Smoothness slider or Alpha channel of Specular map).
- Normal maps: Tangent-space (purple-ish, default), Fix Now button (ensures correct import, Normal Map toggle), strength (slider 0-2, scales normal intensity). Detail normal maps (secondary normal map, tiling for micro-detail, combined with main normal via blending).
- Emission: Self-illuminated materials (glowing screens, neon signs, lava). Emission map (RGB texture, emissive areas colored), HDR color (emission intensity >1 for bloom, use HDR color picker). Global Illumination (Emission > Baked/Realtime, contributes to lightmaps, lights nearby surfaces).

**Performance Optimization:**
- Reduce Pixel Light Count: Quality Settings > Pixel Light Count = 2-4 (forward path, limits per-object lights, additional lights rendered per-vertex = cheaper but lower quality). Profile (Frame Debugger shows additional passes per light, reduce light count if many passes).
- Shadow optimization: Quality Settings > Shadows > Shadow Distance = 50-100m (shadows beyond distance culled, major savings), Shadow Cascades = 2 (mobile) or 4 (PC/console), Shadow Resolution = Medium/High (Low=512 blocky, High=2048 smooth but expensive). Per-light shadows (disable shadows on unimportant lights, only hero lights cast shadows).
- Occlusion Culling: Window > Rendering > Occlusion Culling (bake occlusion data, culls objects behind walls/terrain), enable in Camera (Camera > Occlusion Culling = enabled). Savings: 30-50% draw calls in dense scenes (interiors, cities), minor overhead (occlusion queries, negligible on modern hardware).
- Static Batching: Mark static objects (Inspector > Static checkbox, or Static dropdown > Batching Static), Project Settings > Player > Static Batching = enabled. Combines static meshes (single draw call for multiple objects, same material). Memory cost (duplicates mesh data, increases build size, balance batching vs memory). Alternative: GPU Instancing (for repeated objects, enable in material, zero memory cost, requires instancing-compatible shader).

**Migration to URP/HDRP:**
- Assess project: Small project (few custom shaders, mostly Standard materials) = migration straightforward (few days), large project (many custom surface shaders, complex effects) = migration significant (weeks/months, risky mid-development). Timing: early development (migrate now, minimal rework), late development (defer to post-launch, avoid disruption).
- Material upgrade: Automatic (Edit > Render Pipeline > Universal/HD > Upgrade Project Materials, converts Standard to URP/Lit or HDRP/Lit), manual fixes (custom shaders require rewrite, surface shaders → vertex/fragment with URP/HDRP lighting). Test thoroughly (validate all materials render correctly, check lighting/shadows).
- Shader porting: Surface shaders (incompatible with SRP, rewrite as vertex/fragment using URP/HDRP shader library), vertex/fragment shaders (update includes: `UnityCG.cginc` → `Core.hlsl`, `Lighting.cginc` → `Lighting.hlsl`, rewrite lighting code using SRP functions). Shader Graph (alternative to manual porting, visual authoring, URP/HDRP compatible).
- Lighting changes: Enlighten removed (URP/HDRP use Progressive Lightmapper only, no realtime GI, use Light Probes + dynamic lights instead), Subtractive deprecated (use Baked Indirect or Shadowmask in URP/HDRP), Post-Processing (Built-In uses PP Stack v2 package, URP has integrated post-processing, HDRP uses Volume system, reconfigure effects).

**Platform-Specific:**
- **PC**: Forward or Deferred (few lights = forward, many lights = deferred), High quality (4-8 pixel lights, 4 shadow cascades, soft shadows, 2048-4096 shadow resolution, MSAA 4x), Standard shader (full PBR, all texture maps). Built-In viable but URP recommended (better performance, future support).
- **Consoles**: Deferred typical (PS4/Xbox One support G-buffer, many lights common in console games), Medium/High quality (2-4 pixel lights for forward areas, 2-4 shadow cascades, 1024-2048 shadows, MSAA 2x in forward). Built-In functional but URP optimized (URP better for console memory/bandwidth constraints).
- **Switch**: Forward only (deferred too expensive, G-buffer memory prohibitive), Low/Medium quality (1-2 pixel lights, 2 shadow cascades, 512-1024 shadows, no MSAA), simplified shaders (Mobile/Diffuse instead of Standard, or Standard with minimal maps). URP strongly recommended (Built-In unoptimized for Switch, URP designed for low-power hardware).
- **Mobile**: Forward only (tile-based GPUs, deferred unsupported or inefficient), Very Low/Low quality (0-1 pixel lights, 1-2 shadow cascades, 256-512 shadows, no MSAA), Mobile shaders (Built-In Mobile/Diffuse, Mobile/Unlit, Standard too expensive). URP essential (Built-In mobile performance poor, URP optimized for mobile rendering, mandatory for mobile viability).

## Common Pitfalls

**Too Many Forward Passes**: Developer uses Forward path (default), places 10 lights in scene (thinking all render), frame rate drops (Forward renders additional lights as separate passes, 10 lights = 9 additional passes per object = 10x overdraw). Symptom: Frame Debugger shows many additional passes ("ForwardAdd" pass repeated per light), GPU fragment-bound. Solution: Reduce light count (use baked lighting for static lights, limit realtime to 2-4 key lights), or switch to Deferred (Player Settings > Rendering Path = Deferred, all lights rendered in one pass).

**Deferred Transparency Issues**: Developer enables Deferred (for many lights), transparent particles render incorrectly (sorting issues, particles appear in front of opaque objects when should be behind). Deferred limitation (transparent objects rendered in separate forward pass, sorting between deferred opaque + forward transparent unreliable). Symptom: Particles/UI popping in front of geometry, Z-fighting, incorrect depth sorting. Solution: Soft particles (enable in Quality Settings, particles fade near geometry, hides sorting issues), or switch to Forward (if transparency critical, Forward handles alpha blending correctly, sacrifice deferred multi-light efficiency).

**Surface Shader Incompatibility**: Developer migrates project to URP (assigns URP asset), custom surface shaders break (surface shaders Built-In only, not supported in SRP). Materials turn magenta, console errors ("Surface shader not supported"). Symptom: All custom surface shader materials pink, Standard shader materials work (upgraded to URP/Lit), custom shaders broken. Solution: Rewrite surface shaders as vertex/fragment (use URP shader library, implement lighting manually), or use Shader Graph (visual shader authoring, replaces surface shaders, URP/HDRP compatible, no code required).

**Enlighten Realtime GI Dependency**: Project uses Realtime GI (Enlighten, dynamic global illumination), developer upgrades to URP/HDRP, realtime GI missing (Enlighten removed from SRP, not supported). Lighting looks wrong (no indirect bounces, dark interiors). Symptom: Lighting flat after migration (only direct lighting, no GI), Realtime GI toggle missing in Lighting window. Solution: Bake lighting (use Baked GI, Progressive Lightmapper, static indirect lighting), Light Probes for dynamic objects (sample baked GI, objects receive indirect lighting), dynamic lights (add realtime lights to simulate bounced light, or use HDRP SSGI for screen-space approximation).

## Tools & Workflow

**Rendering Path Setup**: Player Settings > Other Settings > Rendering Path = Forward/Deferred (sets default), per-camera override (Camera component > Rendering Path = Use Player Settings/Forward/Deferred/Legacy Vertex Lit). Quality Settings > Pixel Light Count (Forward path only, limits per-object lights). Validate: Frame Debugger shows "RenderForward" passes (forward) or "Deferred" + "Deferred Lighting" (deferred).

**Standard Shader**: Create material (Assets > Create > Material), Shader dropdown = Standard (default). Configure: Rendering Mode (Opaque/Cutout/Fade/Transparent), Workflow (Metallic/Specular toggle at top), assign textures (Albedo, Normal, Metallic/Specular, Occlusion, Emission), adjust properties (Metallic/Smoothness sliders, Tiling/Offset). Preview: Material Inspector shows sphere preview (rotate to see material under lighting).

**Lightmap Baking**: Window > Rendering > Lighting > Scene (lightmapping settings). Mark static (select objects, Inspector > Static > Lightmap Static checkbox). Configure: Lightmapper = Progressive GPU (fastest), Indirect Resolution = 2 (lightmap texels per unit), Lightmap Resolution = 40 (texels per unit), Compress Lightmaps (enabled, reduces size), Ambient Occlusion (enable for contact shadows). Bake: Generate Lighting button (bakes lightmaps + light probes, stores in Lighting Data Asset). Result: Lighting folder with lightmaps (exr or png, baked lighting textures).

**Quality Settings**: Project Settings > Quality (list of quality levels). Select level (Very Low/Low/Medium/High/Ultra/Custom), configure (Pixel Light Count, Shadows, Texture Quality, Anti Aliasing, etc.). Platform defaults (set per platform: PC=High, Console=Medium, Mobile=Low), runtime switching (`QualitySettings.SetQualityLevel(2)` = switches to Medium, applies immediately).

**Frame Debugger**: Window > Analysis > Frame Debugger (shows Built-In rendering). Enable (click Enable), step through (expand hierarchy, see passes: Shadow Caster, RenderForward base pass, RenderForward add passes, Transparent, Post-Processing). Identify issues (too many add passes = too many lights, expensive shaders, transparency overdraw). Disable when done (click Disable, Frame Debugger overhead = slow Editor).

**Profiler**: Window > Analysis > Profiler > Rendering (Built-In rendering stats). Metrics: SetPass Calls (state changes, target <100-200), Draw Calls (individual draws, target <1000-2000), Batches (after batching, lower = better), Triangles (total tris rendered), Vertices (total verts). Deep Profile: Profiler > Deep Profile (shows individual shader passes, lighting calculations, identifies expensive functions). GPU Profiler: Profiler > GPU (shows GPU timing per pass, forward base/add passes, shadows, post-processing).

## Related Topics

- [18.1 SRP Architecture](18-01-SRP-Architecture.md) - SRP fundamentals
- [18.2 Universal Render Pipeline](18-02-Universal-Render-Pipeline.md) - URP migration
- [12.1 Introduction to Shaders](12-01-Introduction-To-Shaders.md) - Shader basics
- [13.1 Lighting Fundamentals](13-01-Lighting-Fundamentals.md) - Lighting setup

---

[← Previous: 18.3 High-Definition Render Pipeline](18-03-High-Definition-Render-Pipeline.md) | [Next: 18.5 Custom Render Pipelines →](18-05-Custom-Render-Pipelines.md)
