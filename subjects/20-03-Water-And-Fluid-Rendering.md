# 20.3 Water and Fluid Rendering

[← Back to Chapter 20](../chapters/20-Specialized-Rendering.md) | [Main Index](../README.md)

Water rendering simulates realistic surfaces: wave animation (vertex/normal displacement), reflections (planar/SSR/cubemap), refraction (underwater distortion), foam, and caustics.

---

## Overview

Water Techniques: Vertex displacement (animates water surface geometry, sine waves or FFT), normal mapping (animated normals for wave detail, no geometry cost), reflections (planar reflections = mirror-quality expensive, SSR = cheaper screen-space, cubemap = cheapest static), refraction (distorts underwater objects, UV offset based on normals), underwater effects (fog, caustics, color grading = oceanic look). Complexity levels: Simple (animated normal map, cubemap reflection, cheap = mobile), Standard (vertex waves, SSR, refraction, moderate = PC/console), Advanced (FFT waves, planar reflections, volumetric underwater, expensive = high-end only).

Fluid Simulation: 2D fluid sim (Navier-Stokes, compute shader, height-field waves = lakes/ponds), 3D fluid sim (SPH particles, voxel-based, very expensive = research-level, not typical for games). Unity buoyancy (rigidbody floats on water, raycast detects water surface, applies upward force). Dynamic interactions: boats create wakes (spawn particles, disturb water surface via vertex shader), swimming (character animation + underwater effects). Performance: water expensive (reflections, transparency, complex shaders, budget 3-10ms for hero water, 0.5-2ms for simple water).

Shader Complexity: Simple water (unlit, animated UVs, single texture, no reflections = <0.5ms), Standard water (PBR, normal map, cubemap reflections, refraction = 2-5ms), Advanced water (multiple wave layers, planar reflections, foam, caustics = 5-10ms). Mobile: simple only (avoid reflections, basic transparency, <1ms budget).

## Key Concepts

- **Wave Animation**: Vertex displacement (sine waves deform mesh, creates swells). Implementation: vertex shader offsets Y position, `vertexWS.y += amplitude * sin(dot(vertexWS.xz, waveDir) * frequency + _Time.y * speed);` Multiple waves (sum 3-5 sine waves with different directions/frequencies, realistic ocean swell). Gerstner waves (advanced, circular motion, more realistic but expensive, `offset.x = amplitude * sin(...); offset.y = amplitude * cos(...); offset.z = amplitude * sin(...);`). FFT waves (Fast Fourier Transform, spectral synthesis, ultimate realism = expensive compute shader, ocean simulation research-level).
- **Normal Map Animation**: Animate normal map UVs (scroll two normal maps at different speeds, blend, creates moving water detail without geometry cost). Shader: `float3 normal1 = UnpackNormal(tex2D(_NormalMap, uv + _Time.y * _ScrollSpeed1)); float3 normal2 = UnpackNormal(tex2D(_NormalMap, uv * 1.3 - _Time.y * _ScrollSpeed2)); float3 normal = BlendNormals(normal1, normal2);` Cheaper than vertex waves (normal-only animation, no vertex processing, sufficient for calm water or distant surfaces). Combine: vertex waves (large swells) + animated normals (small ripples).
- **Reflections**: Planar reflections (mirror-perfect, render scene from mirrored camera, render to texture, sample in water shader, very expensive = 2x scene rendering), Screen-Space Reflections (SSR, raytrace in screen space, good quality for visible surfaces, cheaper than planar = 2-5ms), Cubemap reflections (static environment map, cheapest = <0.1ms, acceptable for skybox-only reflections), Hybrid (cubemap for sky, SSR for dynamic objects, balance quality/cost). PBR: reflection based on smoothness (rough water = blurred reflections, smooth = sharp), Fresnel (reflections stronger at glancing angles, water surface = high Fresnel, typical n=1.33).
- **Refraction**: Distort underwater view (simulate light bending through water). Implementation: sample scene color with UV offset, `float2 offset = normal.xy * _RefractionStrength; float4 refractionColor = tex2D(_CameraOpaqueTexture, screenUV + offset);` Requires scene color texture (URP Camera Opaque Texture, HDRP color pyramid, render objects before water = water reads scene). Depth-based: fade refraction at shallow water (depth difference between water surface and underwater geometry, deep = strong refraction, shallow = weak).
- **Foam**: White foam at wave crests and shorelines (intersection with geometry). Depth-based foam: sample depth buffer, `float depth = sceneDepth - surfaceDepth; float foam = saturate(1 - depth / _FoamDistance);` (foam appears where water intersects objects, shore edges, rocks). Wave crest foam: based on wave height or normal steepness, `float crest = saturate(worldPos.y - _WaveHeight); foam += crest * _CrestFoam;` Texture: foam texture (tiling noise texture, animated UVs, masks foam regions). Color: white or light blue, additive blending (adds to water color, brightens surface).
- **Underwater Rendering**: Detect camera underwater (compare camera Y position to water surface Y), apply underwater post-processing (fog, color grading, caustics). Underwater fog: exponential fog (density increases with depth, `fogFactor = exp(-depth * _FogDensity);`), blue-green tint (oceanicColor * fogFactor + underwaterFog). Caustics: animated caustic texture (projected from above, simulates light refraction patterns on seafloor), or raytraced caustics (compute shader, traces light rays through water surface, expensive). Volume: underwater as post-process (full-screen effect, applied when camera submerged), or local volume (box collider triggers underwater state, script enables effects).

## Best Practices

**Simple Water Shader:**
- Animated normals only: Two normal maps (scroll at different speeds, blend), no vertex displacement (flat geometry, waves simulated via normals only). Shader: `uv1 = uv + _Time.y * _Speed1; uv2 = uv * _Scale2 - _Time.y * _Speed2; normal = BlendNormals(tex2D(_Normal1, uv1), tex2D(_Normal2, uv2));`
- Cubemap reflection: Sample reflection cubemap (based on view direction reflected across normal), blend with water color. Fresnel: `float fresnel = pow(1 - dot(viewDir, normal), 5); color = lerp(waterColor, reflectionColor, fresnel);` (reflections strong at edges, weak looking straight down).
- Transparency: Alpha blend (water = transparent, underwater visible), depth fade (water opacity increases with depth, deep water opaque, shallow transparent). Shader: `alpha = saturate(depth / _DepthTransparency);`
- Performance: <1ms (simple shader, one normal sample, cubemap reflection = single sample, cheap), suitable for mobile (disable reflection on low-end, normal animation only).

**Standard Water Shader:**
- Vertex waves: 2-3 sine waves (different directions/frequencies, sum offsets). Code: `for (int i = 0; i < 3; i++) { offset.y += _Amplitude[i] * sin(dot(worldPos.xz, _Direction[i]) * _Frequency[i] + _Time.y * _Speed[i]); }` Update normals (recalculate normal from displaced vertices, or approximate via derivative of wave function).
- Screen-Space Reflections (SSR): Enable in Volume (URP/HDRP SSR post-processing), water shader samples reflection texture (unity_SpecCube0 or SSR texture), blends with Fresnel. Quality: SSR quality settings (ray count, Max distance, denoising), balance performance vs reflection detail.
- Refraction: Sample _CameraOpaqueTexture (URP provides scene color before transparent pass), offset UVs by normal.xy, `refractionColor = tex2D(_CameraOpaqueTexture, screenUV + normal.xy * _RefractionStrength);` Depth mask (disable refraction at water edges, depth fade prevents artifacts).
- Foam: Depth-based intersection foam (shore foam, object foam), wave crest foam (based on wave peaks). Combine: `foamMask = depthFoam + crestFoam;` Apply foam texture: `foamColor = tex2D(_FoamTexture, uv * _FoamTiling + _Time.y * _FoamSpeed) * foamMask;` Add to final color (water + foam).
- Performance: 2-5ms (vertex waves, SSR, refraction, foam = moderate cost), suitable for PC/console (mainstream water quality).

**Advanced Water Shader:**
- FFT waves: Compute shader implements FFT (generates height field from ocean spectrum, Phillips spectrum or JONSWAP), outputs height/normal/displacement textures, vertex shader samples textures (applies FFT-generated displacement). Realistic: ocean-like swell patterns, correct wave physics. Cost: compute shader expensive (FFT per frame = 2-5ms, or pre-compute, cache, stream results). Research-level: complex implementation (DSP knowledge required, or use plugins: Crest Ocean System asset).
- Planar reflections: Render scene from mirrored camera (position below water surface, flipped Y, render to RenderTexture), water shader samples reflection texture. Setup: additional Camera (mirrors main camera, targets RenderTexture), Water shader uses `_ReflectionTex`. Optimizations: lower resolution reflection (half-res = 4x faster), culling (reflection camera culls distant objects, reduces draw calls), LOD bias (reflection uses lower LODs).
- Volumetric underwater: 3D underwater fog (voxel-based or raymarch), caustics (compute shader traces light through surface, renders caustic patterns on geometry), god rays (volumetric lighting, light shafts underwater). Expensive: 5-10ms (full volumetric, planar reflections, FFT waves), high-end only (RTX GPUs, PS5/Xbox Series X).

**Interaction Systems:**
- Buoyancy: Rigidbody floats (raycast downward detects water surface Y, compare rigidbody Y position, apply upward force if submerged). Code: `if (rbPosition.y < waterSurfaceY) { rb.AddForce(Vector3.up * buoyancyForce * submersionDepth); }` Multiple sample points (boat has 4 corner raycasts, average determines orientation, realistic tilting).
- Wakes: Boat creates wake particles (spawn particles behind boat, velocity-based emission, foam particles trail), or dynamic water (boat modifies water surface vertices in radius, creates depression/wave, compute shader applies forces to water sim). Simple: particle wakes (cheap, visual only, no water deformation). Complex: interactive water (boat disturbs fluid sim, expensive, compute-heavy).
- Splashes: Detect object entering water (collider enters water volume, trigger OnTriggerEnter), spawn splash particles (impact location, particle system explosion effect), play sound (water splash audio). Ripples: spawn decal or modify water normal map (temporary ripple, fades over time, simulates disturbance).

**Underwater Effects:**
- Camera detection: Script checks camera Y vs water surface Y (`Camera.main.transform.position.y < waterPlane.position.y`), toggles underwater mode (enables fog, caustics, color grading). Or: trigger volume (box collider on water, OnTriggerStay detects camera inside).
- Underwater fog: Global Volume (add Fog override, enable when underwater, disable when above), or shader fog (apply in water shader fragment, exponential depth fog). Settings: Fog Color = blue-green (oceanic tint), Density = high (visibility 10-50m underwater, vs kilometers above water).
- Caustics: Animated caustic texture (3D texture or flipbook, scrolls over surfaces, projects from above via additional light or shader), or compute caustics (render water surface depth from light's perspective, compute refraction, render caustic patterns). Shader: sample caustic texture in underwater fragment shaders, add to lighting: `finalColor += causticsTexture.Sample(worldPos.xz * causticsScale + _Time.y * causticsSpeed) * causticsIntensity;`
- Color grading: Underwater post-process Volume (Color Adjustments override, reduce saturation, shift hue toward blue, reduce brightness = murky underwater look). Or: shader-based (global shader keyword UNDERWATER, shaders apply color grading when enabled).

**Platform-Specific:**
- **PC**: Advanced water (vertex waves, planar/SSR reflections, refraction, foam, underwater effects, caustics), high-quality (4-5 wave layers, high-res reflection 1024x1024, detailed normals). Budget: 5-10ms for hero water (ocean, lakes), 2-5ms for standard water. FFT viable (if compute budget available, research-level quality).
- **Consoles**: Standard water (vertex waves, SSR, refraction, foam), moderate quality (2-3 waves, medium-res reflection 512x512 or SSR only). Budget: 3-5ms. Planar reflections (optional, PS5/Series X viable if lower resolution, PS4/Xbox One = SSR only). Optimize: reflection camera culls aggressively, lower LOD bias.
- **Switch**: Simple water (animated normals only, no vertex waves, cubemap reflection only, minimal refraction), low quality (single normal map, static cubemap, no foam or minimal). Budget: 1-2ms. Underwater: disable caustics (too expensive), fog only (exponential fog, color grading, <0.5ms).
- **Mobile**: Very simple water (animated normals optional, static cubemap reflection, no refraction, no underwater effects), ultra-low quality (single texture, scrolling UVs, alpha blend only). Budget: 0.5-1ms. High-end: animated normals possible (two normal maps, blended, acceptable on flagship devices). Low-end: static texture (no animation, pure transparency, <0.2ms).

## Common Pitfalls

**Missing Opaque Texture**: Developer implements refraction (samples _CameraOpaqueTexture in water shader), texture not available (URP Camera Opaque Texture disabled, or Built-In pipeline = feature unavailable). Water renders black or magenta (texture missing, shader errors). Symptom: Water surface wrong color (black, magenta, or no refraction visible), console warnings ("Texture not found"). Solution: Enable Opaque Texture (URP asset > Rendering > Opaque Texture = enabled, camera renders scene color before transparent pass), or disable refraction (if feature unavailable, remove refraction code, use simple transparency instead).

**Planar Reflection Performance**: Developer adds planar reflection (mirror-quality water, reflection camera renders entire scene), frame rate halves (rendering scene twice, reflection pass = full scene cost + water pass). Symptom: Profiler shows two rendering passes (Main Camera + Reflection Camera, combined cost 20-30ms), GPU bottleneck. Solution: Optimize reflection camera (lower resolution, e.g., half-res 512x512 instead of 1080p, 4x faster), aggressive culling (reflection camera culls distant objects, far plane 100m instead of 1000m), disable shadows (reflection pass shadows = optional, disable for performance), or switch to SSR (Screen-Space Reflections cheaper, 2-5ms vs 10-20ms for planar).

**Underwater Never Triggers**: Developer creates underwater effects (fog, caustics, color grading), camera never triggers (comparison `camera.y < water.y` but water is rippling, camera occasionally below displaced vertices but above base water Y, state flickers). Symptom: Underwater effects flash on/off (camera at water surface, wave animation causes flickering trigger), inconsistent state. Solution: Trigger threshold (add buffer, `camera.y < water.y - 0.5`, ensures camera fully submerged before triggering), smooth transition (lerp underwater amount over 0.5-1 second, fade effects in/out, eliminate flickering), or trigger volume (box collider slightly below water surface, OnTriggerStay = reliable detection, avoids vertex displacement issues).

**Depth Artifacts at Edges**: Developer implements depth-based foam/refraction (samples depth buffer, compares to water surface depth), artifacts at screen edges or camera near water (depth buffer precision issues, floating-point errors, foam appears everywhere or refraction breaks). Symptom: Foam covering entire water surface (depth comparison incorrect), refraction warping at edges (UV offset exceeds screen bounds). Solution: Clamp depth difference (saturate depth comparison, `depth = saturate((sceneDepth - surfaceDepth) / foamDistance)`, prevents negative or excessive values), clamp UV offset (clamp refractionUV to [0,1] range, prevents sampling outside screen), bias depth (add small epsilon to depth comparison, avoids precision issues: `depth = max(0, sceneDepth - surfaceDepth - 0.01)`).

## Tools & Workflow

**Water Plane Setup**: Create plane mesh (GameObject > 3D Object > Plane, or quad for smaller water), scale (large plane for ocean, e.g., 1000x1000 units, or multiple tiled planes), assign water material (custom water shader). Position: Y = 0 (water surface level, objects above = dry, below = submerged). Tessellation: subdivide plane (water with vertex waves needs geometry, default plane = 100 tris insufficient, use 100x100 subdivided plane = 10K tris, or import from DCC tool).

**Water Shader Template**: Shader Graph (URP/HDRP Shader Graph, visual water shader, nodes for normal animation, Fresnel, transparency), or HLSL (custom ShaderLab water shader). Basic structure: vertex shader (wave displacement if needed), fragment shader (normal sampling + blend, Fresnel calculation, reflection/refraction sampling, foam, final color compositing). Properties: _NormalMap, _NormalScale, _ScrollSpeed, _WaterColor, _ReflectionTex, _RefractionStrength, _FoamDistance, etc.

**Planar Reflection Script**: C# script creates reflection camera (copies main camera settings, flips Y, renders to RenderTexture), attaches to water plane. Code: `Camera reflectionCam = new GameObject("ReflectionCam").AddComponent<Camera>(); reflectionCam.CopyFrom(Camera.main); reflectionCam.targetTexture = reflectionRT;` Per-frame: position reflection camera (mirror main camera position across water plane Y), render (reflectionCam.Render()), assign to material (waterMaterial.SetTexture("_ReflectionTex", reflectionRT)). Optimize: reflection camera culling mask (exclude UI, particles, reduce draw calls), LOD bias (reflectionCam.lodBias = 2, uses lower LODs, faster rendering).

**URP Opaque Texture**: URP Asset > Rendering > Opaque Texture = enabled (URP renders scene color before transparent pass, stores in _CameraOpaqueTexture). Shader samples: `TEXTURE2D(_CameraOpaqueTexture); SAMPLER(sampler_CameraOpaqueTexture); float4 sceneColor = SAMPLE_TEXTURE2D(_CameraOpaqueTexture, sampler_CameraOpaqueTexture, screenUV);` Use for refraction (UV offset based on normals), or underwater effects (sample scene, apply fog/color grading).

**Underwater Volume Script**: C# script detects camera underwater, toggles Volume. Code: `if (Camera.main.transform.position.y < waterPlane.position.y) { underwaterVolume.weight = 1; } else { underwaterVolume.weight = 0; }` Or smooth: `underwaterVolume.weight = Mathf.Lerp(underwaterVolume.weight, targetWeight, Time.deltaTime * 2);` Volume Profile: Fog (blue-green, high density), Color Adjustments (saturation -20, hue shift +30 toward blue), Vignette (darken edges, claustrophobic feel).

**Caustics Texture**: Create animated 3D texture or flipbook (multiple caustic frames, baked from caustic generator tools, or asset store). Shader samples: `float3 causticsUV = worldPos * causticsScale + float3(0, _Time.y * causticsSpeed, 0); float caustics = SAMPLE_TEXTURE3D(_CausticsTexture, samplerCausticsTexture, causticsUV).r;` Apply: add caustics to lit underwater surfaces (fragment shader: `lighting += caustics * causticsIntensity;`), or as decal (project caustics texture from light direction onto geometry).

**Profiling Water**: Unity Profiler > GPU: shows water rendering cost (vertex shading for waves, fragment for reflection/refraction/transparency). Frame Debugger: shows water pass (transparent queue, after opaque, samples opaque texture for refraction, renders water surface), reflection camera pass (if planar, separate camera rendering, 2x scene cost). Optimize: reduce vertices (lower tessellation, fewer wave calculations), simplify shader (remove refraction, SSR instead of planar, reduce foam complexity), LOD (distant water uses simpler shader, near water full quality).

## Related Topics

- [13.3 Post-Processing](13-03-Post-Processing.md) - Underwater post-processing
- [12.2 Writing Custom Shaders](12-02-Shader-Types.md) - Custom water shaders
- [19.3 Procedural Effects](19-03-Procedural-Effects.md) - Fluid simulation
- [20.4 Sky and Atmospheric Rendering](20-04-Sky-And-Atmospheric-Rendering.md) - Sky reflections in water

---

[← Previous: 20.2 Vegetation Rendering](20-02-Vegetation-Rendering.md) | [Next: 20.4 Sky and Atmospheric Rendering →](20-04-Sky-And-Atmospheric-Rendering.md)
