# 20.5 UI Rendering

[← Back to Chapter 20](../chapters/20-Specialized-Rendering.md) | [Main Index](../README.md)

UI rendering displays HUD, menus, buttons overlaying 3D scene. Unity: UGUI (Unity GUI, Canvas-based, immediate batching), or UI Toolkit (retained-mode, vector graphics, editor+runtime). Performance critical: batch draw calls, atlas textures, minimize Canvas rebuilds.

---

## Overview

Canvas System: All UI elements children of Canvas component (renders UI separately from scene, three modes: Screen Space Overlay, Screen Space Camera, World Space). Screen Space Overlay (renders on top, 2D pixel coordinates, no camera needed, cheapest = <1ms for hundreds of elements), Screen Space Camera (renders by UI camera, can apply post-processing, depth-tested, moderate cost), World Space (UI in 3D space, nameplates, diegetic UI, perspective projection). Canvas hierarchy (nested canvases possible, separate batches, each Canvas = separate rendering pass).

Batching: UI drawn in batches (multiple elements combined into single draw call if same material+texture, critical for performance). Conditions: same Canvas, same material (default UI material), same texture (atlas), same Z order (render order, overlapping breaks batch). Atlas: combine multiple UI sprites into single texture (reduces material swaps, enables batching, Unity generates atlas automatically or manually via Sprite Atlas). Rebuild: Canvas recalculates geometry when UI changes (expensive, 1-5ms for complex layouts, minimize by caching, avoiding unnecessary updates).

UGUI vs UI Toolkit: UGUI (traditional, GameObject-based, immediate-mode layout, mature = all features, runtime-proven), UI Toolkit (modern, UXML/USS like HTML/CSS, retained-mode = efficient updates, vector graphics = resolution-independent, editor UI primarily, runtime support Unity 2021+). Choice: UGUI for shipped games (stable, wide support, extensive documentation), UI Toolkit for new projects (modern workflow, better editor integration, future-proof, learning curve).

## Key Concepts

- **Canvas Render Modes**: Screen Space Overlay (renders flat on screen, ignores camera, 2D pixel coordinates, always on top = occludes 3D scene, cheapest = no camera setup, <1ms), Screen Space Camera (renders by specific camera, respects camera depth, can apply post-processing to UI, camera culling mask includes UI layer). World Space (Canvas in 3D scene, Rect Transform positioned in world, perspective/orthographic camera renders it, useful for nameplates, in-world menus, VR interfaces, depth-tested against 3D geometry). Mode selection (Overlay for HUD = always visible, Camera for UI with effects = bloom/DOF on UI, World for 3D-integrated UI = health bars above characters).
- **UI Batching**: Combines multiple UI elements into single draw call (same material+texture). Process: Canvas gathers UI elements (Graphic components: Image, Text, RawImage), sorts by Z order (rendering order, bottom to top), groups consecutive elements with same material+texture into batch. Break conditions: different texture (sprite from different atlas), different material (custom shader), Canvas override (nested Canvas, Z order jump, Mask component). Optimization: use Sprite Atlas (pack all UI sprites together, single texture), minimize material variations (default UI material for most, custom materials sparingly), avoid frequent Z reordering (stable hierarchy, predictable batching).
- **Sprite Atlas**: Combines multiple sprites into single texture (reduces draw calls, enables batching). Unity: Sprite Atlas asset (right-click > Create > 2D > Sprite Atlas), drag sprites into Objects for Packing, settings (Max Texture Size = 2048 typical, Compression, Filter Mode). Auto-generated (Unity packs sprites tightly, power-of-two atlas), manual packing (control positions, padding). Runtime: Unity replaces sprite references with atlas versions (automatic, GetSprite() returns atlas sprite, batches draw calls). Benefits: fewer textures (single 2048x2048 atlas vs dozens of small textures), better batching (all UI elements reference atlas = same texture = batch), less memory (atlas compressed once vs individual sprites).
- **Canvas Rebuild**: When UI changes (text updates, image enabled/disabled, layout changes), Canvas marks dirty (recalculates geometry, layout, graphic updates). Cost: 1-5ms for complex Canvas (hundreds of elements, nested layouts, TMP text), negligible for simple (<100 elements). Triggers: SetActive(true/false) on UI element, Text.text = "new", Image.sprite = newSprite, Rect Transform changes (position, scale, rotation), Layout Group updates. Optimization: avoid frequent updates (cache UI elements, update only when needed, not every frame), split Canvas (multiple canvases, static Canvas = never rebuilds, dynamic Canvas = frequently updated UI only), disable raycast targets (non-interactive elements, Raycast Target = false, skips event system overhead).
- **Event System**: Handles UI input (mouse clicks, touch, gamepad), raycasts to find UI elements under pointer, triggers events (OnClick, OnPointerEnter, etc.). Components: EventSystem (one per scene, manages input), Standalone Input Module (PC/console input, mouse+keyboard), Input System integration (new Input System package, replaces Standalone). Raycast: tests pointer position against UI elements (Graphic Raycast on Canvas, tests if pixel hits UI element, sorted by Z order = top element receives event). Performance: raycast every frame (input check, <0.1ms for simple UI, 1-2ms for thousands of elements), optimization (disable Raycast Target on decorative elements, use Raycast Padding to reduce hit test area, limit UI hierarchy depth).
- **TextMeshPro (TMP)**: Advanced text rendering (Signed Distance Field fonts, crisp at any scale, rich text, outlines/shadows). Unity: install TMP (Package Manager > TextMeshPro, or Unity prompts on first usage), TMP fonts (Font Asset = SDF texture, generate from TTF), components (TextMeshPro - Text for Screen Space, TextMeshPro - Text (UI) for Canvas). Benefits: resolution-independent (scales without blur, single SDF texture = all sizes), rich text (<color>, <size>, <b>, <i> tags), material effects (outlines, underlays, glows, bevels). Performance: GPU-friendly (SDF shader, single draw call per text element if same font), faster than Unity Text (legacy Text component = dynamic font atlas, more overhead). Setup: Font Asset (Window > TextMeshPro > Font Asset Creator, import TTF, generate SDF texture, Atlas Resolution 512-2048), Material (TMP material with effects, assign to TextMeshPro component).
- **UI Toolkit (Runtime)**: Modern UI (UXML for structure, USS for styling, C# for logic). Components: UIDocument (replaces Canvas, references UXML asset), Panel Settings (render settings, resolution, scaling). Workflow: create UXML (UI Builder or text editor, HTML-like <VisualElement> hierarchy), create USS (styles, CSS-like rules: color, font, padding), reference in UIDocument (Attach UXML, Panel Settings for rendering). Benefits: retained-mode (updates only changed elements, not entire Canvas), vector graphics (USS-based styling = resolution-independent), data binding (MVVM pattern, automatic UI updates from data), editor integration (same UI system for editor windows and runtime). Drawbacks: newer (less mature than UGUI, fewer tutorials, Unity 2021+ for runtime support), learning curve (UXML/USS different from GameObject hierarchy). Use case: new projects (modern workflow), tools (editor extensions, inspectors, consistent with Unity editor UI), scalable UI (multi-resolution, data-driven UIs).

## Best Practices

**Canvas Setup:**
- Render mode selection: Screen Space Overlay (HUD, menus, simple UI, cheapest), Screen Space Camera (UI with post-processing, depth-tested UI, AR overlays), World Space (nameplates, in-world buttons, VR menus, diegetic interfaces).
- Multiple canvases: separate static and dynamic (static Canvas = HUD frame, health bar background, never changes = renders once + cached, dynamic Canvas = health bar fill, text updates, rebuilds frequently). Nested canvases (each Canvas = separate batch, isolate frequently updating elements). Example: root Canvas Overlay (static), child Canvas (dynamic health bars only, updates every frame, doesn't dirty static canvas).
- Canvas Scaler: handles resolution (Canvas Scaler component, UI Scale Mode = Scale With Screen Size, Reference Resolution = 1920x1080, UI scales to match screen). Scale Mode (Constant Pixel Size = fixed pixels, Scale With Screen Size = proportional scaling, Constant Physical Size = real-world size for mobile).

**Sprite Atlas Optimization:**
- Create atlas: Assets > Create > 2D > Sprite Atlas, name "UI_Atlas", drag all UI sprites (icons, buttons, panels) into Objects for Packing. Settings: Max Texture Size = 2048 (4096 if needed for many sprites, avoid smaller = multiple atlases), Format = RGBA Compressed ETC2/BC7/ASTC (platform-specific), Filter Mode = Bilinear (default), Include in Build = true.
- Usage: Canvas Image components automatically reference atlas sprites (Unity resolves sprite to atlas at runtime), no code changes needed (Image.sprite = originalSprite works, Unity substitutes atlas version). Verify batching: Window > Analysis > Frame Debugger, check Canvas.RenderBatch (should show 1-2 draw calls for entire UI if atlas used, many calls = broken batching).
- Avoid atlas fragmentation: separate atlases per UI screen (MainMenu_Atlas, HUD_Atlas, Inventory_Atlas, prevents mixing = better batching), update policy (Late Binding = atlas packs at build, Include in Build, runtime efficient), use power-of-two (Max Size 1024/2048/4096, GPU-friendly).

**Canvas Rebuild Minimization:**
- Cache references: `[SerializeField] Text healthText;` (assign in Inspector, avoid GetComponent() every frame, faster + doesn't dirty Canvas). Update only when changed: `if (newHealth != currentHealth) { healthText.text = newHealth.ToString(); currentHealth = newHealth; }` (avoids unnecessary rebuilds).
- Disable raycast targets: UI elements not interactive (decorative images, background panels, static text), Inspector > Graphic > Raycast Target = unchecked (Event System skips, saves raycasts, doesn't affect rendering).
- Avoid Layout Groups: LayoutGroup components (Horizontal/Vertical/Grid Layout Group) recalculate every frame (expensive, 1-3ms for complex layouts), use only when necessary (dynamic lists, auto-layout menus), prefer manual positioning (Rect Transform anchors, fixed positions, predictable layout, no rebuild overhead).

**Event System Optimization:**
- Raycast Padding: Graphic Raycast component (on Canvas), Blocking Mask (limits raycast layers, Physics 2D Raycaster if UI mixed with 2D sprites), Raycast Padding (shrinks hit area, reduces false positives). Limit hierarchy depth (flat UI hierarchy = faster raycasts, deep nesting = slower traversal).
- Input throttling: don't check input every frame if unnecessary (menus, pause screen = no need for frame-perfect input, check input every 0.1s or on event only). Disable EventSystem when UI hidden (pause menu closed, disable EventSystem GameObject, saves raycasts + input processing).

**TextMeshPro:**
- Font Asset generation: Window > TextMeshPro > Font Asset Creator, Source Font File (TTF), Atlas Resolution (512 for small fonts, 1024-2048 for large or many characters), Character Set (ASCII for English, Unicode for internationalization), Padding (5-10 for outlines, prevents SDF artifacts), Render Mode (SDFAA = best quality, balances SDF + anti-aliasing). Generate Font Atlas (creates SDF texture, material, saves as asset).
- Material presets: TMP material variants (outline, shadow, glow), create presets (Material > Duplicate, configure Outline Width, Outline Color, save as preset), assign to TMP component (Material Preset slot). Avoids per-text material creation (single preset = batches all text with same preset).
- Rich text: use sparingly (each <color> or <size> tag = separate mesh, breaks batching, <color=red>Critical</color> acceptable, avoid dozens of tags per text). Formatting: <b>, <i>, <u>, <s> (bold, italic, underline, strikethrough), <size=20>, <color=#FF0000>, <link="id"> (for hyperlinks, OnClick events).

**UI Toolkit (Runtime):**
- UXML structure: create UXML (Assets > Create > UI Toolkit > UI Document), UI Builder (open UXML, visual editor, drag VisualElements = Label, Button, Image). Hierarchy: <ui:VisualElement> root, children <ui:Label text="Health"/>, <ui:Button text="Start"/>. USS: styles (create USS, attach to UXML, rules `.button { background-color: blue; border-radius: 5px; }`).
- UIDocument component: GameObject > UI Toolkit > UI Document, assign UXML asset (Source Asset), Panel Settings (create PanelSettings asset, resolution, DPI scaling). Rendering: Panel Renderer renders UI (similar to Canvas), batches VisualElements (efficient retained-mode, updates only dirty elements).
- C# integration: `var root = GetComponent<UIDocument>().rootVisualElement;` (access UI), query elements `var button = root.Q<Button>("StartButton");`, register callbacks `button.RegisterCallback<ClickEvent>(OnStartClicked);`. Data binding (USS variables, bind data to UI properties, automatic updates).

**Platform-Specific:**
- **PC**: High-resolution UI (1920x1080 or higher, Reference Resolution 1920x1080, Canvas Scaler = Scale With Screen Size). Rich UI (TMP with outlines/shadows, complex layouts, post-processing on UI if Screen Space Camera). Batching (aim <10 draw calls for UI, Sprite Atlas mandatory, Frame Debugger verify).
- **Consoles**: Moderate resolution (1920x1080, same as PC, safe area margins for TVs = 5-10% border, UI inset to avoid cutoff on old TVs). Gamepad navigation (Event System > First Selected, navigate UI with D-pad, ensure focus visible = highlight selected button). Performance (target <5 draw calls, disable Canvas rebuilds during gameplay = static UI).
- **Switch**: Lower resolution (1280x720 docked, 1280x720 handheld, Canvas Scaler matches), simplified UI (fewer elements, larger buttons for handheld touch, no small text <18pt). Batching critical (aim <5 draw calls, aggressive atlasing, avoid Layout Groups = too expensive). Memory (small atlas 1024x1024, ASTC compression, unload unused UI assets).
- **Mobile**: Minimal UI (720p-1080p, Canvas Scaler = Scale With Screen Size, Reference Resolution 1280x720), touch-friendly (large buttons >80px, no hover states = touch no hover, instant feedback OnPointerDown). Overdraw critical (UI often fullscreen = high overdraw, minimize transparency, use opaque panels where possible, disable invisible UI = SetActive(false) not just alpha=0). Batching (aim <3 draw calls, single atlas 1024x1024 ASTC, TMP for text = efficient, avoid Unity Text = slow dynamic atlas).

## Common Pitfalls

**Broken UI Batching**: Developer creates UI (dozens of sprites, buttons, icons), Frame Debugger shows 50+ draw calls (each sprite separate batch, batching failed). Symptom: poor UI performance (5-10ms UI rendering, Profiler shows Canvas.BuildBatch expensive, many SetPass calls). Cause: sprites from different textures (no atlas, or multiple atlases), custom materials (shader variations), Z order breaks (overlapping elements with different textures). Solution: Sprite Atlas (pack all UI sprites into single atlas, ensures same texture = batching), check Frame Debugger (identify which elements break batch, hovering shows sprite/material, fix by atlasing or reordering), minimize materials (use default UI material, custom materials only when necessary = shaders, separate Canvas for custom material UI).

**Canvas Rebuilds Every Frame**: Developer updates health bar (healthText.text = health.ToString() every Update()), UI stutters (Profiler shows Canvas.SendWillRenderCanvases = 3-5ms every frame, Canvas constantly rebuilding). Symptom: performance spikes (UI updates lag, especially complex Canvas with Layout Groups, mobile drops to 20 FPS). Cause: unnecessary updates (text changes even when value same, Image.enabled toggled, Transform changes, Layout Group recalculates). Solution: Update only when changed (`if (health != lastHealth) { healthText.text = health.ToString(); lastHealth = health; }`), disable Layout Groups (use manual positioning, anchors, avoid auto-layout if static), split Canvas (static Canvas = never updates, dynamic Canvas = only frequently changing elements, isolates rebuilds).

**EventSystem Raycasts Expensive**: Developer has 1000+ UI elements (inventory grid, 50x20 items), input laggy (clicking items delayed, Profiler shows GraphicRaycaster.Raycast = 5ms per frame). Symptom: UI input lag (button clicks delayed, hover effects slow, especially on mobile). Cause: Raycast Target enabled on all elements (decorative images, backgrounds, static text, EventSystem tests all = expensive), deep hierarchy (nested Layout Groups, raycasts traverse entire tree). Solution: Disable Raycast Target (select decorative elements, Inspector > Graphic > Raycast Target = unchecked, EventSystem skips, reduces tests by 50-90%), use Raycast Padding (GraphicRaycaster component, shrinks hit areas, fewer overlaps), limit UI complexity (flatten hierarchy, avoid deep nesting, 3-5 levels max).

**TextMeshPro SDF Artifacts**: Developer uses TMP (generates font atlas, Padding = 0), text has jagged outlines (SDF bleeding, harsh edges, outline cuts off). Symptom: low-quality text (outline pixelated, glow artifacts, especially at small sizes <12pt or large >72pt). Cause: insufficient atlas padding (SDF requires padding for effects, 0 padding = artifacts, Outline bleeds into adjacent characters), low atlas resolution (512 for many characters = crowded, SDF quality drops). Solution: Regenerate font (Window > TextMeshPro > Font Asset Creator, Padding = 5-10, Atlas Resolution = 1024 or 2048 if many characters, Render Mode = SDFAA), increase SDF scale (TMP material > Outline > Width adjust, or Scale = larger font size = better SDF sampling), or use multiple atlases (separate fonts for UI = 1024 atlas, separate for 3D text = 2048 atlas, optimizes resolution per use case).

## Tools & Workflow

**Canvas Setup**: GameObject > UI > Canvas (creates Canvas GameObject, EventSystem if not exists). Canvas component: Render Mode dropdown (Screen Space Overlay, Screen Space Camera, World Space), Pixel Perfect (checkbox, snaps UI to pixels, prevents blurry sprites on low-res screens), Sort Order (for multiple canvases, higher = renders on top). Canvas Scaler: component on Canvas, UI Scale Mode = Scale With Screen Size (matches Reference Resolution, UI proportional to screen, 1920x1080 typical), Match (0 = match width, 1 = match height, 0.5 = both).

**Sprite Atlas Creation**: Assets > Create > 2D > Sprite Atlas, Inspector > Objects for Packing (drag sprites or folders), settings (Platform = platform-specific overrides, Default > Max Texture Size = 2048, Format = RGBA Compressed, Filter Mode = Bilinear). Pack Preview (button, shows atlas layout, verify packing tight), Include in Build (checkbox, atlas available at runtime, required for runtime usage). Build: Unity packs atlas during build (automatic, no manual step), sprites reference atlas (Image.sprite = sprite, Unity resolves to atlas version).

**Frame Debugger for UI**: Window > Analysis > Frame Debugger, Enable (captures frame), expand tree (find Canvas.RenderBatch), click draw calls (shows which UI elements batched, hovering highlights on screen). Batching: consecutive draw calls with same material+texture = batched (1 SetPass for many elements = good), many SetPass calls = broken batches (different textures, materials, Z order breaks). Fix: atlas sprites (same texture), reorder hierarchy (stable Z order), remove custom materials (default UI material).

**TextMeshPro Font Setup**: Window > TextMeshPro > Font Asset Creator, Source Font File (drag TTF), Atlas Settings (Resolution = 1024, Character Set = ASCII or Custom Character List, Padding = 5-10 for outlines, Packing Method = Optimum), Render Mode = SDFAA (best quality), Generate Font Atlas (processes font, creates SDF texture, material, saves asset). Use: TextMeshPro component > Font Asset (assign generated asset), Material Preset (optional, for outlines/shadows).

**UI Toolkit Workflow**: Create UXML (Assets > Create > UI Toolkit > UI Document), open UI Builder (double-click UXML, visual editor). UI Builder: drag VisualElements from Library (Label, Button, Image, VisualElement = container), hierarchy on left (parent/child), Inspector on right (properties, USS classes). USS: Create StyleSheet (Assets > Create > UI Toolkit > Style Sheet), write rules (`.button { background-color: #4A90E2; }`), attach to UXML (UI Builder > StyleSheets panel > Add Existing USS). Runtime: GameObject > UI Toolkit > UI Document (UIDocument component), Source Asset (assign UXML), Panel Settings (create PanelSettings asset, Theme = None, Resolution), script access (`var root = GetComponent<UIDocument>().rootVisualElement;`).

**Profiler for UI**: Unity Profiler > CPU Usage: shows Canvas.SendWillRenderCanvases (Canvas rebuild time, 1-5ms if dirty, 0ms if clean), Canvas.RenderBatch (UI rendering, <1ms for well-batched UI), EventSystem.Update (input raycasts, <0.5ms). GPU Usage: UI.RenderBatch (GPU time, <1ms typical, >5ms if broken batching or overdraw). Optimize: reduce Canvas rebuilds (update only when changed), improve batching (Sprite Atlas, Frame Debugger), reduce raycasts (disable Raycast Target).

**UI Overdraw Check**: Scene view > Overdraw mode (top-right Shaded dropdown > Overdraw), visualizes pixel overdraw (brighter = more overdraw, white = 10+ layers, red = 5+ layers). UI often high overdraw (fullscreen panels, overlapping images, transparent elements). Optimize: remove invisible elements (backgrounds behind opaque panels, disable SetActive(false)), use opaque (9-slice sprites without alpha, sliced Image = only borders transparent), minimize fullscreen effects (blur, glow = fullscreen overdraw, use sparingly on mobile).

## Related Topics

- [15.1 Render Targets and Frame Buffers](15-01-RenderTexture-Management.md) - UI render textures
- [09.3 Asset Optimization Strategies](10-01-AssetBundle-Fundamentals.md) - UI texture compression
- [18.2 Universal Render Pipeline](18-02-Universal-Render-Pipeline.md) - URP UI rendering
- [16.1 Camera Rendering](16-01-Camera-Fundamentals.md) - Screen Space Camera mode

---

[← Previous: 20.4 Sky and Atmospheric Rendering](20-04-Sky-And-Atmospheric-Rendering.md) | [Next: Chapter 21 →](../chapters/21-Frame-Management.md)
